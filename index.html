<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador Cinematográfico v3.1 - Biodegradação de PET</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #102a43, #1c4966);
            --panel-bg: rgba(23, 43, 77, 0.5);
            --blur-effect: blur(10px);
            --border-color: rgba(137, 207, 240, 0.3);
            --text-primary: #f0f4f8;
            --text-secondary: #a7c0d8;
            --accent-green: #2ecc71;
            --accent-blue: #3498db;
            --font-family: 'Poppins', sans-serif;
        }
        body { margin: 0; padding: 0; background: var(--bg-gradient); font-family: var(--font-family); overflow: hidden; color: var(--text-primary); }
        canvas { display: block; }
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #102a43; z-index: 9999; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; transition: opacity 0.5s ease; }
        .ui-panel { background: var(--panel-bg); backdrop-filter: var(--blur-effect); -webkit-backdrop-filter: var(--blur-effect); border: 1px solid var(--border-color); border-radius: 15px; box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37); }
        #controls { position: absolute; top: 20px; left: 20px; z-index: 100; padding: 20px 25px; width: 330px; transition: transform 0.5s ease-in-out; }
        #controls.controls-hidden { transform: translateX(calc(-100% - 40px)); }
        #toggleUiBtn { position: absolute; top: 20px; right: 20px; z-index: 101; background: var(--panel-bg); border: 1px solid var(--border-color); width: 45px; height: 45px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background 0.3s, transform 0.3s; }
        #toggleUiBtn:hover { background: rgba(255, 255, 255, 0.2); transform: rotate(90deg); }
        #toggleUiBtn svg { width: 24px; height: 24px; fill: var(--text-primary); }
        #controls h3 { text-align: center; margin-top: 0; margin-bottom: 25px; font-weight: 600; color: white; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; }
        .tab-buttons { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 20px; }
        .tab-button { flex-grow: 1; text-align: center; background: transparent; border: none; color: var(--text-secondary); padding: 12px 15px; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s; font-size: 14px; }
        .tab-button.active { color: var(--accent-green); border-bottom-color: var(--accent-green); font-weight: 600; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* --- MODIFICADO: Estilos de Slide Aprimorados --- */
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .slides-wrapper { position: relative; width: 100%; overflow: hidden; }
        .slides-container { display: flex; transition: transform 0.5s ease-in-out; }
        .slide { 
            min-height: 220px; /* Aumentado para mais espaço */
            flex: 1 0 100%; 
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .info-section { padding: 0 10px; }
        .info-section strong {
            color: var(--accent-green);
            font-weight: 600;
        }
        /* Animações de entrada para o conteúdo do slide ativo */
        .slide .info-slide-header, .slide .info-section p {
            opacity: 0; /* Começa invisível */
        }
        .slide.active .info-slide-header {
            animation: fadeInUp 0.5s 0.2s ease-out forwards;
        }
        .slide.active .info-section p {
            animation: fadeInUp 0.5s 0.4s ease-out forwards;
        }
        .info-slide-header { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; }
        .info-slide-header svg { width: 24px; height: 24px; fill: var(--accent-green); flex-shrink: 0; }
        .info-slide-header h4 { margin: 0; color: var(--accent-green); font-size: 16px; }
        .info-section p { margin: 5px 0; line-height: 1.7; font-size: 13.5px; font-weight: 300; }

        .slide-navigation { display: flex; justify-content: space-between; align-items: center; margin-top: 15px; }
        .slide-btn { background: var(--accent-blue); color: white; border: none; border-radius: 50%; width: 30px; height: 30px; font-size: 16px; cursor: pointer; transition: background 0.3s; }
        .slide-btn:hover:not(:disabled) { background: #5dade2; }
        .slide-btn:disabled { background: rgba(0,0,0,0.2); cursor: not-allowed; }
        #slide-indicators { display: flex; }
        .indicator-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--border-color); margin: 0 5px; cursor: pointer; transition: background 0.3s; }
        .indicator-dot.active { background: var(--accent-blue); }
        /* --- Fim das modificações de slide --- */

        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 10px; font-size: 14px; color: var(--text-secondary); font-weight: 300; }
        .value-display { float: right; font-weight: 600; color: white; }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 5px; background: rgba(0,0,0,0.3); border-radius: 5px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--accent-green); cursor: pointer; box-shadow: 0 0 5px var(--accent-green); }
        input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: var(--accent-green); cursor: pointer; border: none; }
        .main-controls { display: flex; justify-content: space-between; margin-bottom: 20px; }
        .main-controls button { flex-grow: 1; margin: 0 5px; padding: 10px 0; display: flex; align-items: center; justify-content: center; gap: 8px; background: transparent; color: white; border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; transition: all 0.3s; }
        .main-controls button:hover:not(:disabled) { background: var(--accent-green); border-color: var(--accent-green); }
        .main-controls button:disabled { background: rgba(0,0,0,0.2); color: #666; border-color: #444; cursor: not-allowed; }
        .main-controls button svg { width: 16px; height: 16px; fill: currentColor; }
        .camera-controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        .camera-btn { padding: 10px; background: rgba(0,0,0,0.2); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 8px; cursor: pointer; transition: all 0.3s; }
        .camera-btn:hover { background: var(--accent-blue); color: white; border-color: var(--accent-blue); }
        .quality-toggle { display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 8px; }
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 26px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.3); transition: .4s; border-radius: 26px; }
        .toggle-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .toggle-slider { background-color: var(--accent-green); }
        input:checked + .toggle-slider:before { transform: translateX(24px); }
        #info { position: absolute; bottom: 20px; right: 20px; z-index: 99; padding: 15px 20px; max-width: 280px; width: 100%; }
        .status { font-size: 16px; font-weight: 600; margin-bottom: 12px; }
        .progress-bar { width: 100%; height: 8px; background: rgba(0,0,0,0.3); border-radius: 8px; overflow: hidden; margin-bottom: 12px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent-blue), var(--accent-green)); transition: width 0.3s ease; }
        #details div { font-size: 14px; color: var(--text-secondary); margin-bottom: 5px; font-weight: 300; }
        #details span { color: white; font-weight: 600; float: right; }
    </style>
</head>
<body>
    <div id="loading-overlay">Carregando Simulador Cinematográfico...</div>
    
    <div id="container">
        <!-- SVG ICONS -->
        <svg width="0" height="0" style="position:absolute"><defs>
            <symbol id="icon-play" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></symbol>
            <symbol id="icon-pause" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></symbol>
            <symbol id="icon-reset" viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></symbol>
            <symbol id="icon-settings" viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61-.25-1.17.59-1.69-.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19-.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22-.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></symbol>
            <symbol id="icon-globe" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></symbol>
            <symbol id="icon-search" viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></symbol>
            <symbol id="icon-gears" viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61-.25-1.17.59-1.69-.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19-.15-.24.42-.12-.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22-.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></symbol>
            <symbol id="icon-recycle" viewBox="0 0 24 24"><path d="m16 13 4-4-4-4v2.5c-3.47.7-6.23 3.33-7.25 6.44.25-1.9 1.7-3.44 3.25-3.94v2.5l4-4zM8 11l-4 4 4 4v-2.5c3.47-.7 6.23-3.33 7.25-6.44-.25 1.9-1.7 3.44-3.25 3.94V11zM12 5.5c-1.87 0-3.5.94-4.46 2.44.5.31 1.07.67 1.63 1.06-1.07 1.83-1.1 3.98.08 5.86.37.58.79 1.1 1.25 1.58.46-.48.88-1 1.25-1.58 1.18-1.88 1.15-4.03.08-5.86.56-.39 1.13-.75 1.63-1.06C15.5 6.44 13.87 5.5 12 5.5z"/></symbol>
            <symbol id="icon-shield" viewBox="0 0 24 24"><path d="M12 1 3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"/></symbol>
        </defs></svg>
        
        <button id="toggleUiBtn" title="Ocultar/Exibir Controles (H)"><svg><use xlink:href="#icon-settings"/></svg></button>
        
        <div id="controls" class="ui-panel">
            <h3>Simulador Cinematográfico</h3>
            <div class="tab-container"><div class="tab-buttons"><button class="tab-button active" data-tab="controls">Controles</button><button class="tab-button" data-tab="info">Informações</button></div><div class="tab-content active" id="controls-tab"><div class="control-group"><label>Velocidade <span id="speedValue" class="value-display">1.0x</span></label><input type="range" id="bacteriaSpeed" min="0.5" max="5" value="1" step="0.1"></div><div class="control-group"><label>Nº de Bactérias <span id="countValue" class="value-display">150</span></label><input type="range" id="bacteriaCount" min="50" max="300" value="150" step="10"></div><div class="main-controls"><button id="startBtn"><svg><use xlink:href="#icon-play"/></svg>Iniciar</button><button id="pauseBtn" disabled><svg><use xlink:href="#icon-pause"/></svg>Pausar</button><button id="resetBtn"><svg><use xlink:href="#icon-reset"/></svg>Resetar</button></div><div class="control-group"><label>Controles de Câmera</label><div class="camera-controls"><button class="camera-btn" id="cameraTop">Topo</button><button class="camera-btn" id="cameraFront">Frontal</button><button class="camera-btn" id="cameraOrbit">Orbital</button><button class="camera-btn" id="cameraReset">Padrão</button></div><div class="quality-toggle"><label for="hdToggle">Qualidade HD</label><label class="toggle-switch"><input type="checkbox" id="hdToggle"><span class="toggle-slider"></span></label></div></div></div>
            <div class="tab-content" id="info-tab">
                <div class="slides-wrapper">
                    <div class="slides-container">
                        <!-- MODIFICADO: Conteúdo do slide reescrito e com tags <strong> -->
                        <div class="slide info-section">
                            <div class="info-slide-header"><svg><use xlink:href="#icon-globe"/></svg><h4>O Problema do Plástico</h4></div>
                            <p>O plástico <strong>PET</strong> está por toda parte, de garrafas a embalagens. O problema? Menos de <strong>30%</strong> é reciclado. O resto polui nosso planeta por séculos, liberando microplásticos perigosos.</p>
                        </div>
                        <div class="slide info-section">
                            <div class="info-slide-header"><svg><use xlink:href="#icon-search"/></svg><h4>A Descoberta</h4></div>
                            <p>Em 2016, uma equipe no Japão encontrou a <i><strong>Ideonella sakaiensis</strong></i>, uma bactéria que evoluiu de forma única para se alimentar de plástico, oferecendo uma nova esperança contra a poluição.</p>
                        </div>
                        <div class="slide info-section">
                           <div class="info-slide-header"><svg><use xlink:href="#icon-gears"/></svg><h4>O Mecanismo</h4></div>
                            <p>A bactéria usa duas enzimas, <strong>PETase</strong> e <strong>MHETase</strong>, que funcionam como <strong>"tesouras moleculares"</strong>. Elas quebram o PET em seus componentes básicos, que são inofensivos para o ambiente.</p>
                        </div>
                        <div class="slide info-section">
                            <div class="info-slide-header"><svg><use xlink:href="#icon-recycle"/></svg><h4>O Potencial Futuro</h4></div>
                            <p>Essa tecnologia permite o <strong>"upcycling"</strong>: reciclar plástico infinitamente sem perda de qualidade. Isso pode criar uma verdadeira <strong>economia circular</strong> e ajudar a limpar ecossistemas poluídos.</p>
                        </div>
                        <div class="slide info-section">
                            <div class="info-slide-header"><svg><use xlink:href="#icon-shield"/></svg><h4>Segurança e Desafios</h4></div>
                            <p>A <i>I. sakaiensis</i> é <strong>segura e não-patogênica</strong>. O maior desafio é a <strong>velocidade</strong>. Cientistas agora trabalham para otimizar as enzimas e tornar o processo viável em escala industrial.</p>
                        </div>
                    </div>
                </div>
                <div class="slide-navigation"><button id="prevSlideBtn" class="slide-btn">❮</button><div id="slide-indicators"></div><button id="nextSlideBtn" class="slide-btn">❯</button></div>
            </div>
            </div>
        </div>
        
        <div id="info" class="ui-panel">
            <div class="status" id="status">Aguardando início...</div><div class="progress-bar"><div class="progress-fill" id="progressFill" style="width: 0%"></div></div><div id="details"><div>Bactérias Ativas<span id="activeBacteria">0</span></div><div>PET Degradado<span id="degradationPercent">0%</span></div><div>Tempo Decorrido<span id="timeElapsed">0s</span></div></div>
        </div>
    </div>

    <script type="importmap">
        { "imports": {
            "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
        } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';

        class BacteriaSimulator {
            constructor() {
                // --- PROPRIEDADES DA SIMULAÇÃO ---
                this.maxBottleHP = 20000; this.bottleHP = this.maxBottleHP;
                this.bacteriaCount = 150; this.bacteriaSpeed = 1.0;
                
                // --- PROPRIEDADES DO RENDER ---
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.composer = new EffectComposer(this.renderer);
                this.clock = new THREE.Clock();

                // --- OBJETOS DA CENA ---
                this.bottle = null; this.labelMesh = null;
                this.waterMesh = null; this.bacteria = []; this.particles = [];
                this.backgroundStars = null; this.keyLight = null;
                this.floor = null; this.reflectorFloor = null;
                
                // --- PÓS-PROCESSAMENTO E TEXTURAS ---
                this.saoPass = null; this.bloomPass = null; this.chromaticAberrationPass = null;
                this.sdLabelTexture = null; this.hdLabelTexture = null;

                // --- ESTADO DA APLICAÇÃO ---
                this.isRunning = false; this.isPaused = false; this.isHD = false;
                this.startTime = 0; this.elapsedTime = 0;
                this.bottleCenter = new THREE.Vector3(0, 3, 0);

                // --- CONTROLES DE CÂMERA ---
                this.cameraMode = 'orbit'; this.cameraAngle = 0;
                this.cameraRadius = 18; this.cameraHeight = 8;
                
                this.init();
            }
            
            init() {
                this.renderer.setPixelRatio(1);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x000000, 0);
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                this.camera.position.set(0, this.cameraHeight, this.cameraRadius);
                this.camera.lookAt(this.bottleCenter);
                
                this.sdLabelTexture = this.createLabelTexture(512);
                this.hdLabelTexture = this.createLabelTexture(1024);
                
                this.setupLighting();
                this.createFloors();
                this.setupPostProcessing();
                this.createBackground();
                this.createDetailedBottle();
                this.updateBacteriaCount();
                
                this.setupUI();
                this.animate();

                document.getElementById('loading-overlay').style.opacity = '0';
                setTimeout(() => document.getElementById('loading-overlay').style.display = 'none', 500);
            }

            createFloors() {
                const floorGeometry = new THREE.PlaneGeometry(50, 50, 100, 100);
                const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x102a43, roughness: 0.8 });
                this.floor = new THREE.Mesh(floorGeometry, floorMaterial);
                this.floor.rotation.x = -Math.PI / 2;
                this.floor.receiveShadow = true;
                this.scene.add(this.floor);
                
                this.reflectorFloor = new Reflector(floorGeometry.clone(), {
                    clipBias: 0.003,
                    textureWidth: window.innerWidth * window.devicePixelRatio,
                    textureHeight: window.innerHeight * window.devicePixelRatio,
                    color: 0x081420,
                    recursion: 1
                });
                this.reflectorFloor.geometry.setAttribute('originalPosition', this.reflectorFloor.geometry.getAttribute('position').clone());
                this.reflectorFloor.rotation.x = -Math.PI / 2;
                this.reflectorFloor.visible = false;
                this.scene.add(this.reflectorFloor);
            }
            
            createDetailedBottle() {
                const bottleGroup = new THREE.Group();
                const points = [ new THREE.Vector2(0, -4), new THREE.Vector2(0.8, -4), new THREE.Vector2(1.1, -3.8), new THREE.Vector2(1.1, 2), new THREE.Vector2(1, 3), new THREE.Vector2(0.4, 4), new THREE.Vector2(0.4, 4.5), new THREE.Vector2(0.45, 4.6) ];
                const bottleGeometry = new THREE.LatheGeometry(points, 32);
                const plasticMaterial = new THREE.MeshPhysicalMaterial({ color: 0xadd8e6, metalness: 0.1, roughness: 0.05, transmission: 0.98, transparent: true, opacity: 0.85, ior: 1.52, side: THREE.DoubleSide });
                const bottleMesh = new THREE.Mesh(bottleGeometry, plasticMaterial);
                bottleMesh.castShadow = true;
                bottleGroup.add(bottleMesh);

                const labelGeometry = new THREE.CylinderGeometry(1.105, 1.105, 2.5, 32, 1, true);
                const labelMaterial = new THREE.MeshStandardMaterial({ map: this.sdLabelTexture, transparent: true, roughness: 0.5 });
                this.labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
                this.labelMesh.position.y = -0.5;
                bottleGroup.add(this.labelMesh);

                const capGeometry = new THREE.CylinderGeometry(0.46, 0.46, 0.4, 24);
                const capMaterial = new THREE.MeshStandardMaterial({ color: 0x2980b9, roughness: 0.3 });
                const capMesh = new THREE.Mesh(capGeometry, capMaterial);
                capMesh.position.y = 4.7;
                capMesh.castShadow = true;
                bottleGroup.add(capMesh);

                const waterGeometry = new THREE.CylinderGeometry(1.05, 1.05, 6, 32, 5);
                waterGeometry.setAttribute('originalPosition', waterGeometry.getAttribute('position').clone());
                const waterMaterial = new THREE.MeshPhysicalMaterial({ color: 0x3e8ee0, metalness: 0, roughness: 0.05, transmission: 0.9, transparent: true, ior: 1.33 });
                this.waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
                this.waterMesh.position.y = -1;
                bottleGroup.add(this.waterMesh);
                
                bottleGroup.position.copy(this.bottleCenter);
                this.bottle = bottleGroup;
                this.scene.add(this.bottle);
            }

            createLabelTexture(resolution) {
                const canvas = document.createElement('canvas');
                canvas.width = resolution;
                canvas.height = resolution / 2;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const scale = resolution / 512;
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 15 * scale;
                ctx.beginPath();
                ctx.moveTo(100 * scale, 80 * scale); ctx.lineTo(60 * scale, 128 * scale); ctx.lineTo(100 * scale, 176 * scale);
                ctx.moveTo(80 * scale, 80 * scale); ctx.lineTo(120 * scale, 80 * scale);
                ctx.moveTo(40 * scale, 128 * scale); ctx.lineTo(60 * scale, 128 * scale); ctx.stroke();
                ctx.fillStyle = '#34495e';
                ctx.font = `bold ${48 * scale}px Poppins`; ctx.fillText('BIO-PET', 150 * scale, 110 * scale);
                ctx.font = `${24 * scale}px Poppins`; ctx.fillText('100% Biodegradável', 150 * scale, 150 * scale);
                return new THREE.CanvasTexture(canvas);
            }
            
            setupPostProcessing() {
                const renderPass = new RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                this.saoPass = new SAOPass(this.scene, this.camera, false, true);
                this.saoPass.params.saoIntensity = 0.008;
                this.saoPass.params.saoScale = 150;
                this.composer.addPass(this.saoPass);

                const ChromaticAberrationShader = {
                    uniforms: { 'tDiffuse': { value: null }, 'amount': { value: 0.003 } },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
                    fragmentShader: `uniform sampler2D tDiffuse; uniform float amount; varying vec2 vUv;
                        void main() {
                           vec2 center = vec2(0.5, 0.5);
                           vec2 dir = vUv - center;
                           float dist = length(dir);
                           gl_FragColor.r = texture2D(tDiffuse, vUv - dir * dist * amount).r;
                           gl_FragColor.g = texture2D(tDiffuse, vUv).g;
                           gl_FragColor.b = texture2D(tDiffuse, vUv + dir * dist * amount).b;
                        }`
                };
                this.chromaticAberrationPass = new ShaderPass(ChromaticAberrationShader);
                this.composer.addPass(this.chromaticAberrationPass);

                this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.85);
                this.bloomPass.threshold = 0.21;
                this.bloomPass.strength = 0.9;
                this.bloomPass.radius = 0.55;
                this.composer.addPass(this.bloomPass);

                this.saoPass.enabled = false;
                this.chromaticAberrationPass.enabled = false;
            }
            
            toggleHD(isEnabled) {
                this.isHD = isEnabled;
                
                const pixelRatio = this.isHD ? Math.min(window.devicePixelRatio, 2) : 1;
                this.renderer.setPixelRatio(pixelRatio);
                const shadowMapSize = this.isHD ? 4096 : 2048;
                this.keyLight.shadow.mapSize.width = shadowMapSize;
                this.keyLight.shadow.mapSize.height = shadowMapSize;
                this.keyLight.shadow.needsUpdate = true;

                this.floor.visible = !this.isHD;
                this.reflectorFloor.visible = this.isHD;

                this.labelMesh.material.map = this.isHD ? this.hdLabelTexture : this.sdLabelTexture;
                this.labelMesh.material.needsUpdate = true;

                this.saoPass.enabled = this.isHD;
                this.chromaticAberrationPass.enabled = this.isHD;
                
                this.bloomPass.strength = this.isHD ? 1.1 : 0.9;
                this.saoPass.params.saoIntensity = this.isHD ? 0.01 : 0.008;
            }

            setupUI() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('bacteriaSpeed').addEventListener('input', (e) => { this.bacteriaSpeed = parseFloat(e.target.value); document.getElementById('speedValue').textContent = `${this.bacteriaSpeed.toFixed(1)}x`; });
                document.getElementById('bacteriaCount').addEventListener('input', (e) => { this.bacteriaCount = parseInt(e.target.value); document.getElementById('countValue').textContent = this.bacteriaCount; if (!this.isRunning) this.updateBacteriaCount(); });
                document.getElementById('cameraTop').addEventListener('click', () => this.setCameraMode('top'));
                document.getElementById('cameraFront').addEventListener('click', () => this.setCameraMode('front'));
                document.getElementById('cameraOrbit').addEventListener('click', () => this.setCameraMode('orbit'));
                document.getElementById('cameraReset').addEventListener('click', () => { this.setCameraMode('orbit'); this.cameraRadius = 18; this.cameraHeight = 8; });
                document.getElementById('toggleUiBtn').addEventListener('click', () => document.getElementById('controls').classList.toggle('controls-hidden'));
                document.addEventListener('keydown', (e) => { if (e.target.tagName.toLowerCase() !== 'input' && e.key.toLowerCase() === 'h') document.getElementById('controls').classList.toggle('controls-hidden'); });
                window.addEventListener('resize', () => this.onWindowResize());

                const hdToggle = document.getElementById('hdToggle');
                hdToggle.addEventListener('change', (e) => this.toggleHD(e.target.checked));
                if (window.devicePixelRatio > 1.5) {
                    hdToggle.checked = true;
                    this.toggleHD(true);
                }
                
                // MODIFICADO: Lógica do Carrossel de Slides
                const tabButtons = document.querySelectorAll('.tab-button'); const tabContents = document.querySelectorAll('.tab-content'); tabButtons.forEach(button => { button.addEventListener('click', () => { const targetTab = button.getAttribute('data-tab'); tabButtons.forEach(btn => btn.classList.remove('active')); tabContents.forEach(content => content.classList.remove('active')); button.classList.add('active'); document.getElementById(`${targetTab}-tab`).classList.add('active'); }); }); const slidesContainer = document.querySelector('.slides-container'); const slides = Array.from(document.querySelectorAll('.slide')); const prevBtn = document.getElementById('prevSlideBtn'); const nextBtn = document.getElementById('nextSlideBtn'); const indicatorsContainer = document.getElementById('slide-indicators'); let currentSlide = 0; slides.forEach((_, index) => { const dot = document.createElement('div'); dot.classList.add('indicator-dot'); dot.addEventListener('click', () => goToSlide(index)); indicatorsContainer.appendChild(dot); }); const indicators = Array.from(indicatorsContainer.children); 
                const goToSlide = (slideIndex) => { 
                    if (slideIndex < 0 || slideIndex >= slides.length) return; 
                    slidesContainer.style.transform = `translateX(-${slideIndex * 100}%)`; 
                    currentSlide = slideIndex; 
                    // Adiciona a classe 'active' ao slide correto para acionar a animação CSS
                    slides.forEach((slide, index) => {
                        slide.classList.toggle('active', index === slideIndex);
                    });
                    updateSlideControls(); 
                }; 
                const updateSlideControls = () => { prevBtn.disabled = currentSlide === 0; nextBtn.disabled = currentSlide === slides.length - 1; indicators.forEach((dot, i) => dot.classList.toggle('active', i === currentSlide)); }; prevBtn.addEventListener('click', () => goToSlide(currentSlide - 1)); nextBtn.addEventListener('click', () => goToSlide(currentSlide + 1)); goToSlide(0);
            }

            onWindowResize() { const width = window.innerWidth; const height = window.innerHeight; this.camera.aspect = width / height; this.camera.updateProjectionMatrix(); this.renderer.setSize(width, height); this.composer.setSize(width, height); if (this.reflectorFloor) { this.reflectorFloor.getRenderTarget().setSize(width * this.renderer.getPixelRatio(), height * this.renderer.getPixelRatio()); } }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = this.clock.getDelta();
                const elapsedTime = this.clock.getElapsedTime();

                this.updateBacteria(delta);
                this.updateParticles(delta);
                this.updateUIStatus();
                this.updateCamera();

                if (this.backgroundStars) { this.backgroundStars.rotation.y += delta * 0.01; }
                if (this.waterMesh) { this.updateWaterSurface(elapsedTime); }
                if (this.reflectorFloor && this.reflectorFloor.visible) {
                    this.updateReflectorFloor(elapsedTime);
                }

                this.composer.render();
            }

            updateReflectorFloor(time) {
                const pos = this.reflectorFloor.geometry.getAttribute('position');
                const originalPos = this.reflectorFloor.geometry.getAttribute('originalPosition');
                for (let i = 0; i < pos.count; i++) {
                    const x = originalPos.getX(i);
                    const y = originalPos.getY(i);
                    const wave1 = 0.08 * Math.sin(x * 0.3 + time * 0.8);
                    const wave2 = 0.08 * Math.sin(y * 0.2 + time * 0.5);
                    pos.setZ(i, wave1 + wave2);
                }
                pos.needsUpdate = true;
            }

            setupLighting() { const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.4); this.scene.add(ambientLight); this.keyLight = new THREE.DirectionalLight(0xFFFFFF, 1.2); this.keyLight.position.set(-10, 10, 10); this.keyLight.castShadow = true; this.keyLight.shadow.mapSize.width = 2048; this.keyLight.shadow.mapSize.height = 2048; this.keyLight.shadow.bias = -0.001; this.scene.add(this.keyLight); const fillLight = new THREE.DirectionalLight(0x88ccff, 0.5); fillLight.position.set(10, 5, -10); this.scene.add(fillLight); const rimLight = new THREE.DirectionalLight(0x4a90e2, 1.0); rimLight.position.set(0, 5, -20); this.scene.add(rimLight); }
            createBackground() { const vertices = []; for (let i = 0; i < 10000; i++) { vertices.push(THREE.MathUtils.randFloatSpread(200), THREE.MathUtils.randFloatSpread(200), THREE.MathUtils.randFloatSpread(200)); } const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); const material = new THREE.PointsMaterial({ color: 0x88c0d0, size: 0.1 }); this.backgroundStars = new THREE.Points(geometry, material); this.scene.add(this.backgroundStars); }
            spawnParticle(position) { const particleGeometry = new THREE.SphereGeometry(0.03, 4, 4); const particleMaterial = new THREE.MeshBasicMaterial({ color: 0x2ecc71, transparent: true }); const particle = new THREE.Mesh(particleGeometry, particleMaterial); particle.position.copy(position); particle.userData = { velocity: new THREE.Vector3((Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5), lifetime: Math.random() * 1.5 + 0.5 }; this.particles.push(particle); this.scene.add(particle); }
            updateBacteria(delta) { if (!this.isRunning || this.isPaused) return; const time = this.clock.getElapsedTime(); let activeBacteria = 0; this.bacteria.forEach((bacterium) => { const userData = bacterium.userData; const distanceToBottle = bacterium.position.distanceTo(this.bottleCenter); if (distanceToBottle > 2.5) { userData.eating = false; const direction = new THREE.Vector3().subVectors(this.bottleCenter, bacterium.position).normalize(); bacterium.position.add(direction.multiplyScalar(userData.speed * delta * 2 * this.bacteriaSpeed)); } else { if (!userData.eating) userData.eating = true; const angle = time * userData.speed * this.bacteriaSpeed * 0.5 + userData.phase; bacterium.position.x = this.bottleCenter.x + Math.cos(angle) * 1.5; bacterium.position.z = this.bottleCenter.z + Math.sin(angle) * 1.5; bacterium.position.y = this.bottleCenter.y + Math.sin(angle * 2.5) * 3; } if (userData.eating) { activeBacteria++; const damage = 1.0 * this.bacteriaSpeed; this.bottleHP = Math.max(0, this.bottleHP - damage); bacterium.material.emissive.setHSL(0.35, 0.9, 0.6 + Math.sin(time * 10) * 0.1); if (Math.random() < 0.1) this.spawnParticle(bacterium.position); } else { bacterium.material.emissive.setHex(bacterium.userData.originalEmissive); } }); document.getElementById('activeBacteria').textContent = activeBacteria; this.updateBottleAppearance(); if (this.bottleHP <= 0) this.complete(); }
            updateParticles(delta) { for (let i = this.particles.length - 1; i >= 0; i--) { const p = this.particles[i]; p.position.add(p.userData.velocity.clone().multiplyScalar(delta)); p.userData.lifetime -= delta; p.material.opacity = p.userData.lifetime; if (p.userData.lifetime <= 0) { this.scene.remove(p); this.particles.splice(i, 1); } } }
            updateWaterSurface(time) { const pos = this.waterMesh.geometry.getAttribute('position'); const originalPos = this.waterMesh.geometry.getAttribute('originalPosition'); for (let i = 0; i < pos.count; i++) { const y = originalPos.getY(i); if (y > 2.9) { const x = originalPos.getX(i); const z = originalPos.getZ(i); const wave = 0.05 * Math.sin(x * 2 + time * 1.5) + 0.05 * Math.sin(z * 2 + time * 1.5); pos.setY(i, y + wave); } } pos.needsUpdate = true; }
            updateBottleAppearance() { if (!this.bottle) return; const degradationPercent = 1 - (this.bottleHP / this.maxBottleHP); const bottleOpacity = Math.max(0, 0.8 - degradationPercent * 1.2); this.bottle.children.forEach((child) => { if (child.material && child.material.transparent) child.material.opacity = bottleOpacity; }); if (this.waterMesh) { const waterLevel = 1 - degradationPercent; this.waterMesh.scale.y = Math.max(0.001, waterLevel); this.waterMesh.position.y = -1 - (degradationPercent * 3); } this.bottle.scale.setScalar(Math.max(0.01, 1 - degradationPercent * 0.5)); }
            start() { if (this.bottleHP <= 0) this.reset(); this.isRunning = true; this.isPaused = false; this.startTime = this.clock.getElapsedTime(); document.getElementById('startBtn').disabled = true; const pauseBtn = document.getElementById('pauseBtn'); pauseBtn.disabled = false; pauseBtn.innerHTML = `<svg><use xlink:href="#icon-pause"/></svg>Pausar`; document.getElementById('status').textContent = 'Biodegradação em progresso...'; }
            pause() { this.isPaused = !this.isPaused; const pauseBtn = document.getElementById('pauseBtn'); if (this.isPaused) { this.isRunning = false; this.elapsedTime += this.clock.getElapsedTime() - this.startTime; pauseBtn.innerHTML = `<svg><use xlink:href="#icon-play"/></svg>Continuar`; document.getElementById('status').textContent = 'Simulação Pausada'; } else { this.isRunning = true; this.startTime = this.clock.getElapsedTime(); pauseBtn.innerHTML = `<svg><use xlink:href="#icon-pause"/></svg>Pausar`; document.getElementById('status').textContent = 'Biodegradação em progresso...'; } }
            reset() { this.isRunning = false; this.isPaused = false; this.bottleHP = this.maxBottleHP; this.startTime = 0; this.elapsedTime = 0; document.getElementById('startBtn').disabled = false; document.getElementById('pauseBtn').disabled = true; document.getElementById('pauseBtn').innerHTML = `<svg><use xlink:href="#icon-pause"/></svg>Pausar`; if(this.bottle) this.scene.remove(this.bottle); this.particles.forEach(p => this.scene.remove(p)); this.particles = []; this.createDetailedBottle(); this.bacteria.forEach(b => this.scene.remove(b)); this.bacteria = []; this.updateBacteriaCount(); this.updateUIStatus(); this.setCameraMode('orbit'); this.cameraRadius = 18; this.cameraHeight = 8; }
            complete() { if (!this.isRunning && this.bottleHP > 0) return; this.isRunning = false; this.bottle.visible = false; document.getElementById('status').textContent = 'Biodegradação Completa!'; document.getElementById('pauseBtn').disabled = true; this.bacteria.forEach(b => b.material.emissive.setHSL(0.35, 1, 0.6)); }
            setCameraMode(mode) {
                this.cameraMode = mode;
                if (this.isRunning || this.isPaused) return;
                const statusEl = document.getElementById('status');
                switch(mode) {
                    case 'orbit': statusEl.textContent = 'Visão Orbital'; break;
                    case 'top': statusEl.textContent = 'Visão Superior'; break;
                    case 'front': statusEl.textContent = 'Visão Frontal'; break;
                    default: statusEl.textContent = 'Aguardando início...';
                }
            }
            updateCamera() { switch(this.cameraMode) { case 'orbit': this.cameraAngle += 0.001; this.camera.position.x = Math.cos(this.cameraAngle) * this.cameraRadius; this.camera.position.z = Math.sin(this.cameraAngle) * this.cameraRadius; this.camera.position.y = this.cameraHeight + Math.sin(this.cameraAngle * 0.5) * 2; break; case 'top': this.camera.position.set(0, 25, 0); break; case 'front': this.camera.position.set(0, 5, this.cameraRadius); break; } this.camera.lookAt(this.bottleCenter); }
            updateUIStatus() { if (!this.isRunning && !this.isPaused && this.cameraMode) this.setCameraMode(this.cameraMode); const degradationPercent = (1 - (this.bottleHP / this.maxBottleHP)) * 100; let time = this.elapsedTime; if (this.isRunning && !this.isPaused) { time = this.elapsedTime + (this.clock.getElapsedTime() - this.startTime); } document.getElementById('progressFill').style.width = `${Math.min(100, degradationPercent)}%`; document.getElementById('degradationPercent').textContent = `${Math.min(100, degradationPercent).toFixed(1)}%`; document.getElementById('timeElapsed').textContent = `${time.toFixed(0)}s`; }
            updateBacteriaCount() { while (this.bacteria.length > this.bacteriaCount) this.scene.remove(this.bacteria.pop()); while (this.bacteria.length < this.bacteriaCount) { const bacteriumGeometry = new THREE.SphereGeometry(0.08, 8, 8); const emissiveColor = new THREE.Color().setHSL(0.35, 0.5, 0.1); const bacteriumMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color().setHSL(0.35, 0.8, 0.6), emissive: emissiveColor, shininess: 80 }); const bacterium = new THREE.Mesh(bacteriumGeometry, bacteriumMaterial); const angle = Math.random() * Math.PI * 2; const radius = 5 + Math.random() * 5; const height = this.bottleCenter.y + (Math.random() - 0.5) * 8; bacterium.position.set(Math.cos(angle) * radius, height, Math.sin(angle) * radius); bacterium.userData = { speed: 0.5 + Math.random(), phase: Math.random() * Math.PI * 2, eating: false, originalEmissive: emissiveColor.getHex() }; this.bacteria.push(bacterium); this.scene.add(bacterium); } }
        }
        
        new BacteriaSimulator();
    </script>
</body>
</html>
